<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity存储系统设计与实现 - Tech Blog</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        /* Article specific styles */
        .article-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 100px 0 80px;
            position: relative;
            overflow: hidden;
        }

        .article-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="50" r="0.5" fill="white" opacity="0.05"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.1;
        }

        .article-title {
            font-size: 3rem;
            font-weight: 700;
            color: white;
            margin-bottom: 1rem;
            position: relative;
            z-index: 1;
        }

        .article-meta {
            display: flex;
            gap: 2rem;
            align-items: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.1rem;
            position: relative;
            z-index: 1;
        }

        .article-meta span {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .article-content {
            padding: 80px 0;
            background: var(--background-color);
        }

        .article-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 3rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .article-body {
            font-size: 1.1rem;
            line-height: 1.8;
        }

        .article-sidebar {
            position: sticky;
            top: 120px;
            height: fit-content;
        }

        .article-body h2 {
            font-size: 2rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            color: var(--text-primary);
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .article-body h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 1.5rem 0 1rem;
            color: var(--text-primary);
        }

        .article-body p {
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
        }

        .article-body ul,
        .article-body ol {
            margin: 1rem 0 1.5rem 2rem;
            color: var(--text-secondary);
        }

        .article-body li {
            margin-bottom: 0.5rem;
        }

        .article-body blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 2rem;
            margin: 2rem 0;
            color: var(--text-secondary);
            font-style: italic;
            background: rgba(0, 122, 255, 0.1);
            padding: 1.5rem;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }

        .article-body pre {
            background: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin: 2rem 0;
            overflow-x: auto;
            position: relative;
        }

        .article-body code {
            background: rgba(0, 122, 255, 0.1);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--primary-color);
        }

        .article-body pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        .article-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: var(--transition);
        }

        .nav-link:hover {
            color: var(--secondary-color);
            transform: translateX(5px);
        }

        .nav-link.prev {
            flex-direction: row-reverse;
        }

        .nav-link.prev:hover {
            transform: translateX(-5px);
        }

        .back-to-blog {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            margin-bottom: 2rem;
            transition: var(--transition);
        }

        .back-to-blog:hover {
            color: var(--primary-color);
            transform: translateX(-5px);
        }

        .toc {
            background: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin: 0;
        }

        .toc h3 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
        }

        .toc ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .toc li {
            margin-bottom: 0.5rem;
        }

        .toc a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: var(--transition);
            display: block;
            padding: 0.25rem 0;
        }

        .toc a:hover {
            color: var(--primary-color);
            transform: translateX(5px);
        }

        @media (max-width: 768px) {
            .article-title {
                font-size: 2rem;
            }

            .article-meta {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }

            .article-body {
                font-size: 1rem;
            }

            .article-body h2 {
                font-size: 1.5rem;
            }

            .article-body h3 {
                font-size: 1.2rem;
            }

            .article-navigation {
                flex-direction: column;
                gap: 1rem;
            }

            .article-layout {
                grid-template-columns: 1fr;
            }

            .article-sidebar {
                position: static;
                order: -1;
            }

            .toc {
                margin: 1rem 0;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <nav class="nav">
            <div class="nav-container">
                <a href="../index.html" class="logo">
                    <span class="logo-icon">◈</span>
                    <span class="logo-text">Tech Blog</span>
                </a>
                <ul class="nav-menu">
                    <li class="nav-item"><a href="../index.html" class="nav-link">首页</a></li>
                    <li class="nav-item"><a href="../index.html#articles" class="nav-link">文章</a></li>
                    <li class="nav-item"><a href="../index.html#about" class="nav-link">关于</a></li>
                    <li class="nav-item"><a href="../index.html#contact" class="nav-link">联系</a></li>
                </ul>
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </nav>
    </header>

    <article>
        <div class="article-header">
            <div class="container">
                <a href="../index.html#articles" class="back-to-blog">
                    <span>←</span>
                    <span>返回博客</span>
                </a>
                <h1 class="article-title">Unity存储系统设计与实现</h1>
                <div class="article-meta">
                    <span>📅 2024-09-27</span>
                    <span>🏷️ Unity开发</span>
                    <span>⏱️ 阅读时间：20分钟</span>
                </div>
            </div>
        </div>

        <div class="article-content">
            <div class="container">
                <div class="article-layout">
                    <div class="article-body">
                        <p>
                            游戏存储系统是游戏开发中的核心功能之一，它负责保存和加载游戏数据，包括玩家进度、设置、存档等。
                            一个良好的存储系统需要考虑数据安全、性能优化、跨平台兼容性等多个方面。
                            本文将详细介绍Unity中存储系统的设计与实现，包括本地存储、云存储、数据序列化等内容。
                        </p>

                        <h2 id="architecture">存储系统架构设计</h2>
                        <p>
                            一个完整的存储系统通常包含以下几个层次：
                        </p>

                        <ul>
                            <li><strong>数据层</strong>：定义需要存储的数据结构</li>
                            <li><strong>序列化层</strong>：将数据转换为可存储的格式</li>
                            <li><strong>存储层</strong>：实际的数据存储和读取</li>
                            <li><strong>管理层</strong>：统一管理存储操作</li>
                        </ul>

                        <p>
                            系统架构图如下，通过分层设计，我们可以实现高度模块化和可扩展的存储系统：
                        </p>

                        <pre><code class="language-csharp">// 存储系统核心接口
public interface IStorageSystem
{
    void Save&lt;T&gt;(string key, T data);
    T Load&lt;T&gt;(string key, T defaultValue = default(T));
    bool Exists(string key);
    void Delete(string key);
    void ClearAll();
}

// 存储数据接口
public interface IStorageData
{
    string GetStorageKey();
    void OnBeforeSave();
    void OnAfterLoad();
}</code></pre>

                        <h2 id="data-structures">数据结构定义</h2>
                        <p>
                            首先定义游戏数据结构，这些结构将决定我们能存储哪些数据：
                        </p>

                        <pre><code class="language-csharp">[System.Serializable]
public class PlayerData
{
    public string playerName;
    public int level;
    public float experience;
    public Vector3 position;
    public int health;
    public int maxHealth;
    public List&lt;string&gt; inventoryItems;
    public Dictionary&lt;string, int&gt; skills;

    public PlayerData()
    {
        playerName = "New Player";
        level = 1;
        experience = 0f;
        position = Vector3.zero;
        health = 100;
        maxHealth = 100;
        inventoryItems = new List&lt;string&gt;();
        skills = new Dictionary&lt;string, int&gt;();
    }
}

[System.Serializable]
public class GameSettings
{
    public float masterVolume = 1f;
    public float musicVolume = 0.8f;
    public float sfxVolume = 1f;
    public bool isFullscreen = true;
    public int resolutionIndex = 0;
    public string language = "zh-CN";
}

[System.Serializable]
public class GameSaveData
{
    public string saveId;
    public DateTime saveTime;
    public PlayerData playerData;
    public GameSettings settings;
    public int currentScene;
    public float playTime;

    public GameSaveData()
    {
        saveId = System.Guid.NewGuid().ToString();
        saveTime = DateTime.Now;
        playerData = new PlayerData();
        settings = new GameSettings();
        currentScene = 0;
        playTime = 0f;
    }
}</code></pre>

                        <h3>数据验证</h3>
                        <p>
                            为了确保数据的完整性，我们需要添加数据验证机制：
                        </p>

                        <pre><code class="language-csharp">public static class DataValidator
{
    public static bool ValidatePlayerData(PlayerData data)
    {
        if (data == null) return false;
        if (string.IsNullOrEmpty(data.playerName)) return false;
        if (data.level < 1) return false;
        if (data.health < 0 || data.health > data.maxHealth) return false;
        if (data.experience < 0) return false;

        return true;
    }

    public static bool ValidateGameSettings(GameSettings settings)
    {
        if (settings == null) return false;
        if (settings.masterVolume < 0 || settings.masterVolume > 1) return false;
        if (settings.musicVolume < 0 || settings.musicVolume > 1) return false;
        if (settings.sfxVolume < 0 || settings.sfxVolume > 1) return false;

        return true;
    }
}</code></pre>

                        <h2 id="serialization">JSON序列化系统</h2>
                        <p>
                            实现一个JSON序列化器来处理数据转换，JSON格式具有良好的可读性和跨平台兼容性：
                        </p>

                        <pre><code class="language-csharp">using UnityEngine;
using System;
using System.IO;
using System.Text;

public class JsonSerializationHelper
{
    public static string Serialize&lt;T&gt;(T obj)
    {
        try
        {
            return JsonUtility.ToJson(obj, true);
        }
        catch (Exception e)
        {
            Debug.LogError($"序列化失败: {e.Message}");
            return null;
        }
    }

    public static T Deserialize&lt;T&gt;(string json)
    {
        try
        {
            return JsonUtility.FromJson&lt;T&gt;(json);
        }
        catch (Exception e)
        {
            Debug.LogError($"反序列化失败: {e.Message}");
            return default(T);
        }
    }

    public static bool TryDeserialize&lt;T&gt;(string json, out T result)
    {
        result = default(T);
        if (string.IsNullOrEmpty(json))
        {
            return false;
        }

        try
        {
            result = JsonUtility.FromJson&lt;T&gt;(json);
            return true;
        }
        catch
        {
            return false;
        }
    }

    // 带压缩的序列化
    public static byte[] SerializeToBytes&lt;T&gt;(T obj)
    {
        string json = Serialize(obj);
        if (string.IsNullOrEmpty(json))
        {
            return null;
        }

        return Encoding.UTF8.GetBytes(json);
    }

    public static T DeserializeFromBytes&lt;T&gt;(byte[] data)
    {
        if (data == null || data.Length == 0)
        {
            return default(T);
        }

        string json = Encoding.UTF8.GetString(data);
        return Deserialize&lt;T&gt;(json);
    }
}</code></pre>

                        <h2 id="local-storage">本地存储实现</h2>
                        <p>
                            实现基于文件系统的本地存储，支持数据加密和跨平台兼容：
                        </p>

                        <pre><code class="language-csharp">using UnityEngine;
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class LocalStorage : IStorageSystem
{
    private readonly string savePath;
    private readonly string encryptionKey;

    public LocalStorage(string subFolder = "GameData", string encryptionKey = null)
    {
        this.encryptionKey = encryptionKey;

        // 获取持久化数据路径
        savePath = Path.Combine(Application.persistentDataPath, subFolder);

        // 确保目录存在
        if (!Directory.Exists(savePath))
        {
            Directory.CreateDirectory(savePath);
        }
    }

    public void Save&lt;T&gt;(string key, T data)
    {
        try
        {
            string json = JsonSerializationHelper.Serialize(data);
            if (string.IsNullOrEmpty(json))
            {
                Debug.LogError("数据序列化失败");
                return;
            }

            // 加密数据
            if (!string.IsNullOrEmpty(encryptionKey))
            {
                json = Encrypt(json, encryptionKey);
            }

            string filePath = GetFilePath(key);
            File.WriteAllText(filePath, json);

            Debug.Log($"数据保存成功: {key}");
        }
        catch (Exception e)
        {
            Debug.LogError($"保存数据失败: {e.Message}");
        }
    }

    public T Load&lt;T&gt;(string key, T defaultValue = default(T))
    {
        try
        {
            string filePath = GetFilePath(key);
            if (!File.Exists(filePath))
            {
                return defaultValue;
            }

            string json = File.ReadAllText(filePath);

            // 解密数据
            if (!string.IsNullOrEmpty(encryptionKey))
            {
                json = Decrypt(json, encryptionKey);
            }

            return JsonSerializationHelper.Deserialize&lt;T&gt;(json);
        }
        catch (Exception e)
        {
            Debug.LogError($"加载数据失败: {e.Message}");
            return defaultValue;
        }
    }

    public bool Exists(string key)
    {
        return File.Exists(GetFilePath(key));
    }

    public void Delete(string key)
    {
        try
        {
            string filePath = GetFilePath(key);
            if (File.Exists(filePath))
            {
                File.Delete(filePath);
                Debug.Log($"数据删除成功: {key}");
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"删除数据失败: {e.Message}");
        }
    }

    public void ClearAll()
    {
        try
        {
            if (Directory.Exists(savePath))
            {
                Directory.Delete(savePath, true);
                Directory.CreateDirectory(savePath);
                Debug.Log("所有数据已清除");
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"清除数据失败: {e.Message}");
        }
    }

    private string GetFilePath(string key)
    {
        return Path.Combine(savePath, $"{key}.json");
    }

    // AES加密
    private string Encrypt(string plainText, string key)
    {
        byte[] keyBytes = Encoding.UTF8.GetBytes(key.PadRight(32).Substring(0, 32));
        byte[] ivBytes = Encoding.UTF8.GetBytes(key.PadRight(16).Substring(0, 16));

        using (Aes aes = Aes.Create())
        {
            aes.Key = keyBytes;
            aes.IV = ivBytes;

            ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

            using (MemoryStream ms = new MemoryStream())
            {
                using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter sw = new StreamWriter(cs))
                    {
                        sw.Write(plainText);
                    }
                    return Convert.ToBase64String(ms.ToArray());
                }
            }
        }
    }

    // AES解密
    private string Decrypt(string cipherText, string key)
    {
        byte[] keyBytes = Encoding.UTF8.GetBytes(key.PadRight(32).Substring(0, 32));
        byte[] ivBytes = Encoding.UTF8.GetBytes(key.PadRight(16).Substring(0, 16));

        using (Aes aes = Aes.Create())
        {
            aes.Key = keyBytes;
            aes.IV = ivBytes;

            ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

            using (MemoryStream ms = new MemoryStream(Convert.FromBase64String(cipherText)))
            {
                using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader sr = new StreamReader(cs))
                    {
                        return sr.ReadToEnd();
                    }
                }
            }
        }
    }
}</code></pre>

                        <h2 id="storage-manager">存储管理器</h2>
                        <p>
                            创建统一的存储管理器来管理所有的存储操作：
                        </p>

                        <pre><code class="language-csharp">using UnityEngine;
using System;
using System.Collections.Generic;

public class StorageManager : MonoBehaviour
{
    public static StorageManager Instance;

    [SerializeField] private string encryptionKey = "YourSecretKey123";
    [SerializeField] private bool autoSave = true;
    [SerializeField] private float autoSaveInterval = 60f;

    private IStorageSystem storage;
    private Dictionary&lt;string, object&gt; cachedData = new Dictionary&lt;string, object&gt;();
    private float nextAutoSaveTime;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            InitializeStorage();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void InitializeStorage()
    {
        storage = new LocalStorage("GameData", encryptionKey);
    }

    private void Update()
    {
        if (autoSave && Time.time >= nextAutoSaveTime)
        {
            AutoSave();
            nextAutoSaveTime = Time.time + autoSaveInterval;
        }
    }

    // 通用保存方法
    public void SaveData&lt;T&gt;(string key, T data)
    {
        storage.Save(key, data);
        cachedData[key] = data;
    }

    // 通用加载方法
    public T LoadData&lt;T&gt;(string key, T defaultValue = default(T))
    {
        if (cachedData.ContainsKey(key))
        {
            return (T)cachedData[key];
        }

        T data = storage.Load&lt;T&gt;(key, defaultValue);
        cachedData[key] = data;
        return data;
    }

    // 游戏存档
    public void SaveGame(GameSaveData saveData)
    {
        try
        {
            // 更新保存时间
            saveData.saveTime = DateTime.Now;

            // 保存数据
            SaveData(saveData.saveId, saveData);

            // 更新存档列表
            List&lt;GameSaveData&gt; saveList = GetSaveList();
            bool found = false;

            for (int i = 0; i &lt; saveList.Count; i++)
            {
                if (saveList[i].saveId == saveData.saveId)
                {
                    saveList[i] = saveData;
                    found = true;
                    break;
                }
            }

            if (!found)
            {
                saveList.Add(saveData);
            }

            SaveData("SaveList", saveList);

            Debug.Log($"游戏存档成功: {saveData.saveId}");
        }
        catch (Exception e)
        {
            Debug.LogError($"游戏存档失败: {e.Message}");
        }
    }

    // 游戏读档
    public GameSaveData LoadGame(string saveId)
    {
        try
        {
            GameSaveData saveData = LoadData&lt;GameSaveData&gt;(saveId);
            if (saveData != null)
            {
                Debug.Log($"游戏读档成功: {saveId}");
                return saveData;
            }
            else
            {
                Debug.LogWarning($"存档不存在: {saveId}");
                return null;
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"游戏读档失败: {e.Message}");
            return null;
        }
    }

    // 获取存档列表
    public List&lt;GameSaveData&gt; GetSaveList()
    {
        return LoadData&lt;List&lt;GameSaveData&gt;&gt;("SaveList", new List&lt;GameSaveData&gt;());
    }

    // 删除存档
    public void DeleteSave(string saveId)
    {
        try
        {
            storage.Delete(saveId);

            // 更新存档列表
            List&lt;GameSaveData&gt; saveList = GetSaveList();
            saveList.RemoveAll(s => s.saveId == saveId);
            SaveData("SaveList", saveList);

            // 清除缓存
            if (cachedData.ContainsKey(saveId))
            {
                cachedData.Remove(saveId);
            }

            Debug.Log($"存档删除成功: {saveId}");
        }
        catch (Exception e)
        {
            Debug.LogError($"删除存档失败: {e.Message}");
        }
    }

    // 自动保存
    private void AutoSave()
    {
        if (GameManager.Instance != null)
        {
            GameSaveData currentData = GameManager.Instance.GetCurrentSaveData();
            if (currentData != null)
            {
                SaveGame(currentData);
                Debug.Log("自动保存完成");
            }
        }
    }

    // 清除缓存
    public void ClearCache()
    {
        cachedData.Clear();
        Debug.Log("存储缓存已清除");
    }

    // 导出存档
    public bool ExportSave(string saveId, string exportPath)
    {
        try
        {
            string filePath = Path.Combine(Application.persistentDataPath, "GameData", $"{saveId}.json");
            if (File.Exists(filePath))
            {
                File.Copy(filePath, exportPath, true);
                Debug.Log($"存档导出成功: {exportPath}");
                return true;
            }
            return false;
        }
        catch (Exception e)
        {
            Debug.LogError($"存档导出失败: {e.Message}");
            return false;
        }
    }

    // 导入存档
    public bool ImportSave(string importPath, string saveId)
    {
        try
        {
            string filePath = Path.Combine(Application.persistentDataPath, "GameData", $"{saveId}.json");
            File.Copy(importPath, filePath, true);

            // 清除相关缓存
            if (cachedData.ContainsKey(saveId))
            {
                cachedData.Remove(saveId);
            }

            Debug.Log($"存档导入成功: {saveId}");
            return true;
        }
        catch (Exception e)
        {
            Debug.LogError($"存档导入失败: {e.Message}");
            return false;
        }
    }
}</code></pre>

                        <h2 id="game-manager">游戏数据管理器</h2>
                        <p>
                            创建专门的游戏数据管理器来处理游戏运行时的数据管理：
                        </p>

                        <pre><code class="language-csharp">using UnityEngine;
using System.Collections.Generic;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance;

    [Header("游戏数据")]
    public GameSaveData currentSaveData;
    public string currentSaveId;
    public float gameTimer;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        // 加载游戏设置
        LoadGameSettings();
    }

    private void Update()
    {
        if (currentSaveData != null)
        {
            gameTimer += Time.deltaTime;
            currentSaveData.playTime = gameTimer;
        }
    }

    // 加载游戏设置
    public void LoadGameSettings()
    {
        GameSettings settings = StorageManager.Instance.LoadData&lt;GameSettings&gt;("GameSettings");
        if (settings != null)
        {
            currentSaveData.settings = settings;
            ApplySettings(settings);
        }
    }

    // 保存游戏设置
    public void SaveGameSettings(GameSettings settings)
    {
        StorageManager.Instance.SaveData("GameSettings", settings);
        if (currentSaveData != null)
        {
            currentSaveData.settings = settings;
        }
    }

    // 应用设置
    private void ApplySettings(GameSettings settings)
    {
        AudioListener.volume = settings.masterVolume;
        // 应用其他设置...
    }

    // 创建新游戏
    public void NewGame()
    {
        currentSaveData = new GameSaveData();
        currentSaveId = currentSaveData.saveId;
        gameTimer = 0f;

        // 初始化玩家数据
        InitializePlayerData();

        Debug.Log("新游戏已创建");
    }

    // 初始化玩家数据
    private void InitializePlayerData()
    {
        currentSaveData.playerData = new PlayerData();
        // 设置初始位置等...
    }

    // 更新玩家数据
    public void UpdatePlayerData(GameObject player)
    {
        if (currentSaveData != null && player != null)
        {
            currentSaveData.playerData.position = player.transform.position;
            currentSaveData.playerData.health = player.GetComponent&lt;Health&gt;().currentHealth;
            // 更新其他玩家数据...
        }
    }

    // 获取当前存档数据
    public GameSaveData GetCurrentSaveData()
    {
        if (currentSaveData != null)
        {
            return currentSaveData;
        }
        return null;
    }

    // 快速保存
    public void QuickSave()
    {
        if (currentSaveData != null)
        {
            // 更新当前场景数据
            currentSaveData.currentScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene().buildIndex;

            // 更新玩家数据
            GameObject player = GameObject.FindGameObjectWithTag("Player");
            if (player != null)
            {
                UpdatePlayerData(player);
            }

            StorageManager.Instance.SaveGame(currentSaveData);
            Debug.Log("快速保存完成");
        }
    }

    // 快速加载
    public void QuickLoad()
    {
        if (!string.IsNullOrEmpty(currentSaveId))
        {
            GameSaveData saveData = StorageManager.Instance.LoadGame(currentSaveId);
            if (saveData != null)
            {
                LoadSaveData(saveData);
            }
        }
    }

    // 加载存档数据
    private void LoadSaveData(GameSaveData saveData)
    {
        currentSaveData = saveData;
        currentSaveId = saveData.saveId;
        gameTimer = saveData.playTime;

        // 切换场景
        if (UnityEngine.SceneManagement.SceneManager.GetActiveScene().buildIndex != saveData.currentScene)
        {
            UnityEngine.SceneManagement.SceneManager.LoadScene(saveData.currentScene);
            // 场景加载完成后会在Start中恢复数据
        }
        else
        {
            // 恢复玩家数据
            RestorePlayerData();
        }

        // 应用设置
        ApplySettings(saveData.settings);

        Debug.Log("存档加载完成");
    }

    // 恢复玩家数据
    private void RestorePlayerData()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            player.transform.position = currentSaveData.playerData.position;
            player.GetComponent&lt;Health&gt;().currentHealth = currentSaveData.playerData.health;
            // 恢复其他玩家数据...
        }
    }

    // 场景加载完成后的处理
    public void OnSceneLoaded()
    {
        if (currentSaveData != null)
        {
            // 延迟一帧确保对象已创建
            StartCoroutine(RestoreDataAfterSceneLoad());
        }
    }

    private System.Collections.IEnumerator RestoreDataAfterSceneLoad()
    {
        yield return null; // 等待一帧
        RestorePlayerData();
    }
}</code></pre>

                        <h2 id="cloud-storage">云存储集成</h2>
                        <p>
                            为游戏添加云存储功能，实现跨设备的存档同步：
                        </p>

                        <pre><code class="language-csharp">using UnityEngine;
using System;
using System.Collections;
using System.Text;
using UnityEngine.Networking;

public class CloudStorage : MonoBehaviour
{
    [SerializeField] private string apiBaseUrl = "https://your-api.com/api";
    [SerializeField] private string apiToken = "your-api-token";

    public IEnumerator UploadSave(string saveId, GameSaveData saveData, Action&lt;bool&gt; onComplete)
    {
        string json = JsonSerializationHelper.Serialize(saveData);
        if (string.IsNullOrEmpty(json))
        {
            onComplete?.Invoke(false);
            yield break;
        }

        WWWForm form = new WWWForm();
        form.AddField("save_id", saveId);
        form.AddField("save_data", json);
        form.AddField("api_token", apiToken);

        using (UnityWebRequest request = UnityWebRequest.Post($"{apiBaseUrl}/save/upload", form))
        {
            yield return request.SendWebRequest();

            if (request.result == UnityWebRequest.Result.Success)
            {
                Debug.Log("云存档上传成功");
                onComplete?.Invoke(true);
            }
            else
            {
                Debug.LogError($"云存档上传失败: {request.error}");
                onComplete?.Invoke(false);
            }
        }
    }

    public IEnumerator DownloadSave(string saveId, Action&lt;GameSaveData&gt; onComplete)
    {
        WWWForm form = new WWWForm();
        form.AddField("save_id", saveId);
        form.AddField("api_token", apiToken);

        using (UnityWebRequest request = UnityWebRequest.Post($"{apiBaseUrl}/save/download", form))
        {
            yield return request.SendWebRequest();

            if (request.result == UnityWebRequest.Result.Success)
            {
                string json = request.downloadHandler.text;
                GameSaveData saveData = JsonSerializationHelper.Deserialize&lt;GameSaveData&gt;(json);
                onComplete?.Invoke(saveData);
            }
            else
            {
                Debug.LogError($"云存档下载失败: {request.error}");
                onComplete?.Invoke(null);
            }
        }
    }

    public IEnumerator GetSaveList(Action&lt;List&lt;GameSaveData&gt;&gt; onComplete)
    {
        WWWForm form = new WWWForm();
        form.AddField("api_token", apiToken);

        using (UnityWebRequest request = UnityWebRequest.Post($"{apiBaseUrl}/save/list", form))
        {
            yield return request.SendWebRequest();

            if (request.result == UnityWebRequest.Result.Success)
            {
                string json = request.downloadHandler.text;
                SaveListResponse response = JsonSerializationHelper.Deserialize&lt;SaveListResponse&gt;(json);
                onComplete?.Invoke(response.saves);
            }
            else
            {
                Debug.LogError($"获取云存档列表失败: {request.error}");
                onComplete?.Invoke(null);
            }
        }
    }

    [System.Serializable]
    private class SaveListResponse
    {
        public List&lt;GameSaveData&gt; saves;
    }

    // 同步本地和云端存档
    public IEnumerator SyncSaves()
    {
        // 获取云端存档列表
        List&lt;GameSaveData&gt; cloudSaves = null;
        yield return StartCoroutine(GetSaveList((saves) => cloudSaves = saves));

        if (cloudSaves == null)
        {
            Debug.LogError("无法获取云端存档列表");
            yield break;
        }

        // 获取本地存档列表
        List&lt;GameSaveData&gt; localSaves = StorageManager.Instance.GetSaveList();

        // 同步逻辑
        foreach (var cloudSave in cloudSaves)
        {
            var localSave = localSaves.Find(s => s.saveId == cloudSave.saveId);

            if (localSave == null)
            {
                // 云端有，本地没有，下载到本地
                yield return StartCoroutine(DownloadSave(cloudSave.saveId, (downloadedSave) => {
                    if (downloadedSave != null)
                    {
                        StorageManager.Instance.SaveGame(downloadedSave);
                    }
                }));
            }
            else if (cloudSave.saveTime > localSave.saveTime)
            {
                // 云端更新，下载到本地
                yield return StartCoroutine(DownloadSave(cloudSave.saveId, (downloadedSave) => {
                    if (downloadedSave != null)
                    {
                        StorageManager.Instance.SaveGame(downloadedSave);
                    }
                }));
            }
        }

        // 上传本地新存档到云端
        foreach (var localSave in localSaves)
        {
            var cloudSave = cloudSaves.Find(s => s.saveId == localSave.saveId);

            if (cloudSave == null || localSave.saveTime > cloudSave.saveTime)
            {
                yield return StartCoroutine(UploadSave(localSave.saveId, localSave, (success) => {
                    if (success)
                    {
                        Debug.Log($"存档 {localSave.saveId} 同步到云端成功");
                    }
                }));
            }
        }

        Debug.Log("存档同步完成");
    }
}</code></pre>

                        <h2 id="best-practices">最佳实践</h2>
                        <h3>1. 数据安全</h3>
                        <ul>
                            <li>使用加密保护敏感数据</li>
                            <li>实现数据校验机制</li>
                            <li>定期备份重要数据</li>
                            <li>添加防作弊措施</li>
                        </ul>

                        <h3>2. 性能优化</h3>
                        <ul>
                            <li>使用缓存减少重复读取</li>
                            <li>异步处理大文件</li>
                            <li>压缩存储数据</li>
                            <li>合理设置自动保存间隔</li>
                        </ul>

                        <h3>3. 用户体验</h3>
                        <ul>
                            <li>提供保存进度提示</li>
                            <li>支持存档导出/导入</li>
                            <li>实现快速保存功能</li>
                            <li>添加存档截图功能</li>
                        </ul>

                        <h3>4. 错误处理</h3>
                        <ul>
                            <li>完善的异常处理机制</li>
                            <li>数据恢复功能</li>
                            <li>存储空间检查</li>
                            <li>网络状态处理</li>
                        </ul>

                        <h2 id="error-handling">错误处理和恢复</h2>
                        <p>
                            健壮的错误处理机制对于存储系统至关重要：
                        </p>

                        <pre><code class="language-csharp">public class StorageErrorHandler : MonoBehaviour
{
    public static void HandleStorageError(Exception e, string operation)
    {
        Debug.LogError($"存储操作失败: {operation} - {e.Message}");

        // 根据错误类型采取不同的恢复策略
        if (e is IOException)
        {
            HandleIOError(e as IOException);
        }
        else if (e is UnauthorizedAccessException)
        {
            HandlePermissionError(e as UnauthorizedAccessException);
        }
        else
        {
            HandleGenericError(e);
        }
    }

    private static void HandleIOError(IOException e)
    {
        Debug.LogWarning("IO错误，可能是存储空间不足或文件被占用");

        // 检查存储空间
        long freeSpace = GetFreeDiskSpace();
        if (freeSpace < 100 * 1024 * 1024) // 小于100MB
        {
            Debug.LogError("存储空间不足");
            // 提示用户清理空间
        }
    }

    private static void HandlePermissionError(UnauthorizedAccessException e)
    {
        Debug.LogWarning("权限错误，无法访问存储位置");
        // 尝试使用备用存储位置
    }

    private static void HandleGenericError(Exception e)
    {
        Debug.LogWarning("通用存储错误");
        // 记录错误日志，尝试恢复
    }

    private static long GetFreeDiskSpace()
    {
        try
        {
            string drive = Path.GetPathRoot(Application.persistentDataPath);
            DriveInfo driveInfo = new DriveInfo(drive);
            return driveInfo.AvailableFreeSpace;
        }
        catch
        {
            return -1;
        }
    }
}</code></pre>

                        <h2 id="platform-compatibility">跨平台兼容性</h2>
                        <p>
                            确保存储系统在不同平台上都能正常工作：
                        </p>

                        <pre><code class="language-csharp">public class PlatformStorageAdapter : MonoBehaviour
{
    public static string GetPlatformSavePath()
    {
        #if UNITY_EDITOR
            return Path.Combine(Application.dataPath, "../Saves");
        #elif UNITY_ANDROID
            return Path.Combine(Application.persistentDataPath, "Saves");
        #elif UNITY_IOS
            return Path.Combine(Application.persistentDataPath, "Saves");
        #elif UNITY_STANDALONE_WIN
            return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "MyGame/Saves");
        #elif UNITY_STANDALONE_OSX
            return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Personal), "Library/Application Support/MyGame/Saves");
        #else
            return Path.Combine(Application.persistentDataPath, "Saves");
        #endif
    }

    public static bool CheckPlatformPermissions()
    {
        #if UNITY_ANDROID
            // 检查Android存储权限
            if (!UnityEngine.Android.Permission.HasUserAuthorizedPermission(UnityEngine.Android.Permission.ExternalStorageWrite))
            {
                UnityEngine.Android.Permission.RequestUserPermission(UnityEngine.Android.Permission.ExternalStorageWrite);
                return false;
            }
        #endif
        return true;
    }

    public static string GetPlatformSpecificKey(string baseKey)
    {
        // 为不同平台添加特定的前缀
        #if UNITY_ANDROID
            return $"android_{baseKey}";
        #elif UNITY_IOS
            return $"ios_{baseKey}";
        #else
            return baseKey;
        #endif
    }
}</code></pre>

                        <blockquote>
                            <p>
                                "存储系统是游戏体验的重要组成部分。
                                一个良好的存储系统不仅要功能完善，还要考虑到用户体验、数据安全和跨平台兼容性。
                                通过合理的设计和实现，我们可以为玩家提供无缝的游戏体验。"
                            </p>
                        </blockquote>

                        <h2>总结</h2>
                        <p>
                            存储系统是游戏开发中不可或缺的重要组成部分。通过合理设计和实现存储系统，我们可以为玩家提供稳定、安全、便捷的游戏数据管理体验。
                        </p>

                        <p>
                            关键要点：
                        </p>
                        <ul>
                            <li>设计灵活的数据结构</li>
                            <li>实现可靠的数据序列化</li>
                            <li>保证数据安全和完整性</li>
                            <li>优化存储性能</li>
                            <li>提供良好的用户体验</li>
                        </ul>

                        <p>
                            通过掌握存储系统的设计和实现，你将能够为玩家提供更加完善的游戏体验，
                            确保游戏数据的安全和可靠性。
                        </p>
                    </div>

                    <div class="article-sidebar">
                        <div class="toc">
                            <h3>目录</h3>
                            <ul>
                                <li><a href="#architecture">存储系统架构设计</a></li>
                                <li><a href="#data-structures">数据结构定义</a></li>
                                <li><a href="#serialization">JSON序列化系统</a></li>
                                <li><a href="#local-storage">本地存储实现</a></li>
                                <li><a href="#storage-manager">存储管理器</a></li>
                                <li><a href="#game-manager">游戏数据管理器</a></li>
                                <li><a href="#cloud-storage">云存储集成</a></li>
                                <li><a href="#best-practices">最佳实践</a></li>
                                <li><a href="#error-handling">错误处理和恢复</a></li>
                                <li><a href="#platform-compatibility">跨平台兼容性</a></li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="article-navigation">
                    <a href="unity-object-pooling.html" class="nav-link prev">
                        <span>← 上一篇</span>
                        <span>Unity对象池技术详解</span>
                    </a>
                    <a href="unity-raycasting.html" class="nav-link next">
                        <span>下一篇</span>
                        <span>Unity射线检测技术详解 →</span>
                    </a>
                </div>
            </div>
        </div>
    </article>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Tech Blog</h3>
                    <p>分享技术，传播知识</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul class="footer-links">
                        <li><a href="../index.html">首页</a></li>
                        <li><a href="../index.html#articles">文章</a></li>
                        <li><a href="../index.html#about">关于</a></li>
                        <li><a href="../index.html#contact">联系</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>技术栈</h4>
                    <ul class="footer-links">
                        <li><a href="#">Unity</a></li>
                        <li><a href="#">C#</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Tech Blog. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="../script.js"></script>

    <script>
        // 目录高亮和滚动效果
        document.addEventListener('DOMContentLoaded', function() {
            const tocLinks = document.querySelectorAll('.toc a');
            const sections = [];

            // 收集所有章节
            tocLinks.forEach(link => {
                const targetId = link.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);
                if (targetSection) {
                    sections.push({
                        id: targetId,
                        element: targetSection,
                        link: link
                    });
                }
            });

            // 滚动时高亮当前章节
            function highlightActiveSection() {
                const scrollPosition = window.scrollY + 150; // 偏移量

                sections.forEach(section => {
                    const sectionTop = section.element.offsetTop;
                    const sectionBottom = sectionTop + section.element.offsetHeight;

                    if (scrollPosition >= sectionTop && scrollPosition < sectionBottom) {
                        // 移除所有活动状态
                        tocLinks.forEach(link => link.classList.remove('active'));
                        // 添加当前活动状态
                        section.link.classList.add('active');
                    }
                });
            }

            // 平滑滚动到章节
            tocLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);

                    if (targetSection) {
                        const offsetTop = targetSection.offsetTop - 100; // 考虑固定导航栏
                        window.scrollTo({
                            top: offsetTop,
                            behavior: 'smooth'
                        });
                    }
                });
            });

            // 监听滚动事件
            window.addEventListener('scroll', highlightActiveSection);
            highlightActiveSection(); // 初始化
        });
    </script>

    <style>
        /* 目录高亮样式 */
        .toc a.active {
            color: var(--primary-color);
            font-weight: 600;
            border-left: 3px solid var(--primary-color);
            padding-left: 1rem;
        }

        .toc a {
            transition: all 0.3s ease;
            padding-left: 1rem;
            border-left: 3px solid transparent;
        }

        /* 平滑滚动 */
        html {
            scroll-behavior: smooth;
        }
    </style>
</body>
</html>