<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity射线检测技术详解 - Tech Blog</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-csharp.min.js"></script>
    <style>
        .article-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 100px 0 80px;
            text-align: center;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .article-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.3;
        }

        .article-header-content {
            position: relative;
            z-index: 1;
            max-width: 800px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .article-header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .article-meta {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .article-content-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 20px;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 60px;
        }

        .article-main {
            min-width: 0;
        }

        .article-sidebar {
            position: sticky;
            top: 20px;
            height: fit-content;
        }

        .toc-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .toc-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .toc-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .toc-list li {
            margin-bottom: 8px;
        }

        .toc-list a {
            color: #666;
            text-decoration: none;
            padding: 5px 0;
            display: block;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
            padding-left: 10px;
        }

        .toc-list a:hover {
            color: #667eea;
            border-left-color: #667eea;
            padding-left: 15px;
        }

        .article-section {
            margin-bottom: 50px;
            scroll-margin-top: 100px;
        }

        .article-section h2 {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .article-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 30px 0 15px;
            color: #444;
        }

        .article-section p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #555;
        }

        .article-section ul, .article-section ol {
            margin: 15px 0;
            padding-left: 20px;
        }

        .article-section li {
            margin-bottom: 8px;
            line-height: 1.6;
            color: #555;
        }

        .article-section pre {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            border: 1px solid #444;
        }

        .article-section code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .highlight-box {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .highlight-box h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .article-content-container {
                grid-template-columns: 1fr;
                gap: 40px;
                padding: 40px 15px;
            }

            .article-header h1 {
                font-size: 2.2rem;
            }

            .article-meta {
                gap: 15px;
                font-size: 1rem;
            }

            .article-sidebar {
                position: static;
            }

            .toc-container {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <nav class="nav">
            <div class="nav-container">
                <a href="../index.html" class="logo">
                    <span class="logo-icon">◈</span>
                    <span class="logo-text">Tech Blog</span>
                </a>
                <ul class="nav-menu">
                    <li class="nav-item"><a href="../index.html#home" class="nav-link">首页</a></li>
                    <li class="nav-item"><a href="../index.html#works" class="nav-link">作品</a></li>
                    <li class="nav-item"><a href="../index.html#articles" class="nav-link">文章</a></li>
                    <li class="nav-item"><a href="../index.html#about" class="nav-link">关于</a></li>
                    <li class="nav-item"><a href="../index.html#contact" class="nav-link">联系</a></li>
                </ul>
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </nav>
    </header>

    <header class="article-header">
        <div class="article-header-content">
            <h1>Unity射线检测技术详解</h1>
            <div class="article-meta">
                <span class="article-date">📅 2024-09-27</span>
                <span class="article-category">🏷️ Unity开发</span>
                <span class="article-reading-time">⏱️ 阅读时间: 18分钟</span>
            </div>
        </div>
    </header>

    <main class="article-content-container">
        <div class="article-main">
            <article class="article-content">
                <section id="introduction" class="article-section">
                    <h2>引言</h2>
                    <p>射线检测（Raycasting）是Unity中最重要的空间检测技术之一，它允许我们检测从某个点沿某个方向发射的虚拟射线与场景中物体的碰撞情况。射线检测在游戏开发中有着广泛的应用，包括瞄准系统、点击检测、AI视觉、物理交互等。</p>
                    <p>本文将深入探讨Unity射线检测的原理、方法和最佳实践，帮助开发者掌握这一关键技术。</p>
                </section>

                <section id="basics" class="article-section">
                    <h2>射线检测基础</h2>
                    <h3>什么是射线检测</h3>
                    <p>射线检测是从一个起点沿特定方向发射一条无限长的虚拟射线，检测这条射线与场景中碰撞体的相交情况。射线检测返回的信息包括：</p>
                    <ul>
                        <li>是否碰撞到物体</li>
                        <li>碰撞点的位置</li>
                        <li>碰撞点的法线</li>
                        <li>碰撞距离</li>
                        <li>碰撞的物体</li>
                    </ul>

                    <h3>基础射线检测</h3>
                    <pre><code class="language-csharp">using UnityEngine;

public class BasicRaycast : MonoBehaviour
{
    public float rayLength = 10f;
    public LayerMask targetLayer;

    private void Update()
    {
        // 从摄像机位置发射射线
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, rayLength, targetLayer))
        {
            Debug.Log($"检测到物体: {hit.collider.name}");
            Debug.Log($"碰撞位置: {hit.point}");
            Debug.Log($"碰撞距离: {hit.distance}");
            Debug.Log($"碰撞法线: {hit.normal}");

            // 在碰撞点绘制标记
            Debug.DrawRay(hit.point, hit.normal * 0.5f, Color.red);
        }

        // 绘制射线
        Debug.DrawRay(ray.origin, ray.direction * rayLength, Color.green);
    }
}</code></pre>
                </section>

                <section id="methods" class="article-section">
                    <h2>射线检测方法详解</h2>
                    <h3>1. Physics.Raycast</h3>
                    <p>最常用的射线检测方法，检测第一个碰撞的物体：</p>
                    <pre><code class="language-csharp">// 重载方法1：基础版本
bool Physics.Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo);

// 重载方法2：带距离限制
bool Physics.Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float distance);

// 重载方法3：带层级过滤
bool Physics.Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float distance, LayerMask layerMask);

// 重载方法4：使用Ray对象
bool Physics.Raycast(Ray ray, out RaycastHit hitInfo);

// 重载方法5：完整版本
bool Physics.Raycast(Ray ray, out RaycastHit hitInfo, float distance, LayerMask layerMask, QueryTriggerInteraction queryTriggerInteraction);

// 使用示例
public void DetectObjects()
{
    Vector3 origin = transform.position;
    Vector3 direction = transform.forward;
    RaycastHit hit;
    float maxDistance = 100f;
    LayerMask targetLayers = LayerMask.GetMask("Enemy", "Obstacle");

    if (Physics.Raycast(origin, direction, out hit, maxDistance, targetLayers))
    {
        Debug.Log($"击中目标: {hit.collider.gameObject.name}");

        // 获取碰撞的组件
        Enemy enemy = hit.collider.GetComponent&lt;Enemy&gt;();
        if (enemy != null)
        {
            enemy.TakeDamage(50);
        }
    }
}</code></pre>

                    <h3>2. Physics.RaycastAll</h3>
                    <p>检测所有与射线相交的物体：</p>
                    <pre><code class="language-csharp">public void DetectAllObjects()
{
    Vector3 origin = transform.position;
    Vector3 direction = transform.forward;
    float maxDistance = 50f;

    RaycastHit[] allHits = Physics.RaycastAll(origin, direction, maxDistance);

    // 按距离排序
    System.Array.Sort(allHits, (a, b) => a.distance.CompareTo(b.distance));

    foreach (RaycastHit hit in allHits)
    {
        Debug.Log($"击中物体: {hit.collider.name}, 距离: {hit.distance}");

        // 绘制碰撞点
        Debug.DrawRay(hit.point, hit.normal * 0.3f, Color.red, 1f);
    }
}</code></pre>

                    <h3>3. Physics.RaycastNonAlloc</h3>
                    <p>避免GC分配的高效射线检测：</p>
                    <pre><code class="language-csharp">public class EfficientRaycast : MonoBehaviour
{
    private RaycastHit[] hits = new RaycastHit[10];
    public float rayLength = 100f;

    private void Update()
    {
        int hitCount = Physics.RaycastNonAlloc(
            transform.position,
            transform.forward,
            hits,
            rayLength
        );

        for (int i = 0; i &lt; hitCount; i++)
        {
            RaycastHit hit = hits[i];
            Debug.Log($"击中: {hit.collider.name}");
        }
    }
}</code></pre>
                </section>

                <section id="special-shapes" class="article-section">
                    <h2>特殊形状检测</h2>
                    <h3>1. 球形检测（SphereCast）</h3>
                    <pre><code class="language-csharp">public void SphereCastDetection()
{
    float sphereRadius = 2f;
    float maxDistance = 50f;
    RaycastHit hit;

    if (Physics.SphereCast(
        transform.position,
        sphereRadius,
        transform.forward,
        out hit,
        maxDistance
    ))
    {
        Debug.Log($"球形检测到: {hit.collider.name}");
        Debug.DrawRay(transform.position, transform.forward * hit.distance, Color.blue);

        // 绘制球形检测范围
        Gizmos.color = Color.cyan;
        Gizmos.DrawWireSphere(transform.position + transform.forward * hit.distance, sphereRadius);
    }
}</code></pre>

                    <h3>2. 盒形检测（BoxCast）</h3>
                    <pre><code class="language-csharp">public void BoxCastDetection()
{
    Vector3 boxSize = new Vector3(2f, 1f, 1f);
    float maxDistance = 30f;
    RaycastHit hit;

    if (Physics.BoxCast(
        transform.position,
        boxSize * 0.5f,
        transform.forward,
        out hit,
        transform.rotation,
        maxDistance
    ))
    {
        Debug.Log($"盒形检测到: {hit.collider.name}");

        // 绘制盒形检测范围
        Gizmos.color = Color.yellow;
        Gizmos.matrix = Matrix4x4.TRS(
            transform.position + transform.forward * hit.distance,
            transform.rotation,
            Vector3.one
        );
        Gizmos.DrawWireCube(Vector3.zero, boxSize);
        Gizmos.matrix = Matrix4x4.identity;
    }
}</code></pre>

                    <h3>3. 胶囊检测（CapsuleCast）</h3>
                    <pre><code class="language-csharp">public void CapsuleCastDetection()
{
    Vector3 point1 = transform.position;
    Vector3 point2 = transform.position + Vector3.up * 2f;
    float radius = 0.5f;
    float maxDistance = 40f;
    RaycastHit hit;

    if (Physics.CapsuleCast(
        point1,
        point2,
        radius,
        transform.forward,
        out hit,
        maxDistance
    ))
    {
        Debug.Log($"胶囊检测到: {hit.collider.name}");
    }
}</code></pre>
                </section>

                <section id="applications" class="article-section">
                    <h2>实际应用场景</h2>
                    <h3>1. 射击游戏瞄准系统</h3>
                    <pre><code class="language-csharp">public class WeaponSystem : MonoBehaviour
{
    public Transform firePoint;
    public float range = 100f;
    public int damage = 25;
    public LayerMask targetLayers;

    public void Shoot()
    {
        if (Physics.Raycast(firePoint.position, firePoint.forward, out RaycastHit hit, range, targetLayers))
        {
            // 创建射击特效
            CreateShootEffect(hit.point);

            // 对目标造成伤害
            IDamageable damageable = hit.collider.GetComponent&lt;IDamageable&gt;();
            if (damageable != null)
            {
                damageable.TakeDamage(damage);
            }

            // 创建弹孔
            CreateBulletHole(hit.point, hit.normal);
        }
    }

    private void CreateShootEffect(Vector3 position)
    {
        GameObject effect = Instantiate(shootEffectPrefab, position, Quaternion.identity);
        Destroy(effect, 1f);
    }

    private void CreateBulletHole(Vector3 position, Vector3 normal)
    {
        GameObject hole = Instantiate(bulletHolePrefab, position, Quaternion.LookRotation(normal));
        hole.transform.position += normal * 0.01f;
        Destroy(hole, 10f);
    }
}</code></pre>

                    <h3>2. 点击交互系统</h3>
                    <pre><code class="language-csharp">public class ClickInteraction : MonoBehaviour
{
    public LayerMask interactableLayers;

    private void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;

            if (Physics.Raycast(ray, out hit, Mathf.Infinity, interactableLayers))
            {
                IInteractable interactable = hit.collider.GetComponent&lt;IInteractable&gt;();
                if (interactable != null)
                {
                    interactable.Interact();
                }
            }
        }
    }
}

public interface IInteractable
{
    void Interact();
    string GetInteractionPrompt();
}</code></pre>

                    <h3>3. AI视觉系统</h3>
                    <pre><code class="language-csharp">public class AIVision : MonoBehaviour
{
    public float visionRange = 30f;
    public float visionAngle = 60f;
    public LayerMask obstacleLayers;
    public LayerMask targetLayers;

    public bool CanSeeTarget(Transform target)
    {
        if (target == null) return false;

        // 检查距离
        float distance = Vector3.Distance(transform.position, target.position);
        if (distance > visionRange) return false;

        // 检查角度
        Vector3 directionToTarget = (target.position - transform.position).normalized;
        float angle = Vector3.Angle(transform.forward, directionToTarget);
        if (angle > visionAngle * 0.5f) return false;

        // 检查障碍物
        RaycastHit hit;
        if (Physics.Raycast(transform.position, directionToTarget, out hit, visionRange, obstacleLayers))
        {
            if (hit.collider.transform != target)
            {
                return false;
            }
        }

        return true;
    }

    public Transform GetVisibleTarget()
    {
        Collider[] targets = Physics.OverlapSphere(transform.position, visionRange, targetLayers);

        foreach (Collider targetCollider in targets)
        {
            Transform target = targetCollider.transform;
            if (CanSeeTarget(target))
            {
                return target;
            }
        }

        return null;
    }

    private void OnDrawGizmos()
    {
        // 绘制视野范围
        Gizmos.color = Color.cyan;
        Gizmos.DrawWireSphere(transform.position, visionRange);

        // 绘制视野角度
        Vector3 leftDir = Quaternion.Euler(0, -visionAngle * 0.5f, 0) * transform.forward;
        Vector3 rightDir = Quaternion.Euler(0, visionAngle * 0.5f, 0) * transform.forward;

        Gizmos.color = Color.blue;
        Gizmos.DrawRay(transform.position, leftDir * visionRange);
        Gizmos.DrawRay(transform.position, rightDir * visionRange);
    }
}</code></pre>

                    <h3>4. 地形高度检测</h3>
                    <pre><code class="language-csharp">public class TerrainHeightDetector : MonoBehaviour
{
    public float detectionDistance = 10f;
    public LayerMask terrainLayers;

    private void Update()
    {
        // 向下检测地面
        if (Physics.Raycast(transform.position, Vector3.down, out RaycastHit hit, detectionDistance, terrainLayers))
        {
            // 调整物体高度
            Vector3 targetPosition = transform.position;
            targetPosition.y = hit.point.y + 1f;
            transform.position = targetPosition;

            // 调整物体朝向
            if (hit.normal != Vector3.up)
            {
                transform.rotation = Quaternion.FromToRotation(Vector3.up, hit.normal) * transform.rotation;
            }
        }
    }
}</code></pre>
                </section>

                <section id="advanced" class="article-section">
                    <h2>高级射线检测技术</h2>
                    <h3>1. 射线检测优化</h3>
                    <pre><code class="language-csharp">public class OptimizedRaycast : MonoBehaviour
{
    // 使用对象池缓存RaycastHit数组
    private RaycastHit[] cachedHits;
    private int maxHits = 32;

    private void Awake()
    {
        cachedHits = new RaycastHit[maxHits];
    }

    public void PerformOptimizedRaycast()
    {
        // 使用NonAlloc避免GC
        int hitCount = Physics.RaycastNonAlloc(
            transform.position,
            transform.forward,
            cachedHits,
            50f
        );

        // 处理碰撞
        for (int i = 0; i &lt; hitCount; i++)
        {
            ProcessHit(cachedHits[i]);
        }
    }

    private void ProcessHit(RaycastHit hit)
    {
        // 处理碰撞逻辑
        if (hit.collider.CompareTag("Enemy"))
        {
            Debug.Log("击中敌人");
        }
    }
}</code></pre>

                    <h3>2. 累积检测（Linecast）</h3>
                    <pre><code class="language-csharp">public class LinecastDetection : MonoBehaviour
{
    public Transform startPoint;
    public Transform endPoint;
    public LayerMask obstacleLayers;

    public bool IsPathClear()
    {
        return !Physics.Linecast(startPoint.position, endPoint.position, obstacleLayers);
    }

    private void OnDrawGizmos()
    {
        if (startPoint != null && endPoint != null)
        {
            Gizmos.color = IsPathClear() ? Color.green : Color.red;
            Gizmos.DrawLine(startPoint.position, endPoint.position);
        }
    }
}</code></pre>

                    <h3>3. 重叠检测（Overlap）</h3>
                    <pre><code class="language-csharp">public class OverlapDetection : MonoBehaviour
{
    public float detectionRadius = 5f;
    public LayerMask targetLayers;

    public void DetectNearbyObjects()
    {
        // 球形重叠检测
        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, detectionRadius, targetLayers);

        foreach (Collider collider in nearbyColliders)
        {
            Debug.Log($"附近物体: {collider.name}");
        }
    }

    // 盒形重叠检测
    public void DetectInBox()
    {
        Vector3 boxSize = new Vector3(10f, 5f, 10f);
        Collider[] boxColliders = Physics.OverlapBox(transform.position, boxSize * 0.5f, Quaternion.identity, targetLayers);

        foreach (Collider collider in boxColliders)
        {
            Debug.Log($"盒内物体: {collider.name}");
        }
    }
}</code></pre>
                </section>

                <section id="optimization" class="article-section">
                    <h2>性能优化和最佳实践</h2>
                    <h3>1. 性能优化技巧</h3>
                    <ul>
                        <li><strong>使用NonAlloc方法</strong>：避免GC分配</li>
                        <li><strong>合理设置检测距离</strong>：避免过远的检测</li>
                        <li><strong>使用层级过滤</strong>：减少不必要的检测</li>
                        <li><strong>帧数控制</strong>：不在每帧进行大量射线检测</li>
                        <li><strong>缓存结果</strong>：对于不频繁变化的对象缓存检测结果</li>
                    </ul>

                    <h3>2. 层级管理</h3>
                    <pre><code class="language-csharp">public class LayerManagement : MonoBehaviour
{
    public LayerMask enemyLayer;
    public LayerMask obstacleLayer;
    public LayerMask interactableLayer;

    // 获取层级名称
    public string GetLayerName(LayerMask layerMask)
    {
        return LayerMask.LayerToName((int)Mathf.Log(layerMask.value, 2));
    }

    // 创建层级掩码
    public LayerMask CreateLayerMask(params string[] layerNames)
    {
        LayerMask mask = 0;
        foreach (string name in layerNames)
        {
            mask |= 1 &lt;&lt; LayerMask.NameToLayer(name);
        }
        return mask;
    }
}</code></pre>

                    <h3>3. 错误处理和调试</h3>
                    <pre><code class="language-csharp">public class SafeRaycast : MonoBehaviour
{
    public void SafeRaycastExample()
    {
        // 检查相机是否存在
        if (Camera.main == null)
        {
            Debug.LogError("主相机不存在");
            return;
        }

        // 检查输入是否有效
        if (Input.mousePosition.x &lt; 0 || Input.mousePosition.x > Screen.width ||
            Input.mousePosition.y &lt; 0 || Input.mousePosition.y > Screen.height)
        {
            return;
        }

        // 执行射线检测
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        if (Physics.Raycast(ray, out RaycastHit hit))
        {
            // 处理碰撞
            HandleHit(hit);
        }
    }

    private void HandleHit(RaycastHit hit)
    {
        try
        {
            // 安全地获取组件
            var component = hit.collider.GetComponent&lt;SomeComponent&gt;();
            if (component != null)
            {
                component.DoSomething();
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"处理碰撞时发生错误: {e.Message}");
        }
    }
}</code></pre>
                </section>

                <section id="troubleshooting" class="article-section">
                    <h2>常见问题和解决方案</h2>
                    <h3>问题1：射线检测不到物体</h3>
                    <p><strong>可能原因</strong>：</p>
                    <ul>
                        <li>物体没有碰撞体组件</li>
                        <li>层级设置不正确</li>
                        <li>射线距离不足</li>
                        <li>物体在触发器模式下</li>
                    </ul>
                    <p><strong>解决方案</strong>：</p>
                    <ul>
                        <li>确保物体有碰撞体</li>
                        <li>检查层级设置</li>
                        <li>调整检测距离</li>
                        <li>设置QueryTriggerInteraction参数</li>
                    </ul>

                    <h3>问题2：性能问题</h3>
                    <p><strong>可能原因</strong>：</p>
                    <ul>
                        <li>每帧进行大量射线检测</li>
                        <li>检测距离过大</li>
                        <li>没有使用层级过滤</li>
                    </ul>
                    <p><strong>解决方案</strong>：</p>
                    <ul>
                        <li>优化检测频率</li>
                        <li>减少检测距离</li>
                        <li>使用层级过滤</li>
                        <li>使用NonAlloc方法</li>
                    </ul>

                    <h3>问题3：精确度问题</h3>
                    <p><strong>可能原因</strong>：</p>
                    <ul>
                        <li>浮点精度问题</li>
                        <li>碰撞体设置问题</li>
                        <li>射线起点位置问题</li>
                    </ul>
                    <p><strong>解决方案</strong>：</p>
                    <ul>
                        <li>调整碰撞体设置</li>
                        <li>使用合适的检测方法</li>
                        <li>添加容错值</li>
                    </ul>
                </section>

                <section id="conclusion" class="article-section">
                    <h2>总结</h2>
                    <p>射线检测是Unity游戏开发中不可或缺的技术，掌握射线检测的各种方法和最佳实践对于开发高质量的游戏至关重要。</p>
                    <p>关键要点：</p>
                    <ul>
                        <li>理解不同射线检测方法的适用场景</li>
                        <li>正确使用层级和距离过滤</li>
                        <li>注意性能优化和错误处理</li>
                        <li>合理选择检测方式（射线、球形、盒形等）</li>
                        <li>结合实际应用场景选择合适的解决方案</li>
                    </ul>

                    <div class="highlight-box">
                        <h4>💡 最佳实践提示</h4>
                        <p>通过熟练掌握射线检测技术，你将能够实现各种复杂的游戏机制和交互效果。记住，性能优化是关键，合理使用层级过滤和NonAlloc方法可以显著提升游戏性能。</p>
                    </div>
                </section>
            </article>

            <div class="article-navigation">
                <a href="../index.html#articles" class="nav-link">← 返回文章列表</a>
            </div>
        </div>

        <aside class="article-sidebar">
            <div class="toc-container">
                <h3 class="toc-title">📋 目录</h3>
                <nav class="toc-list">
                    <ul>
                        <li><a href="#introduction">引言</a></li>
                        <li><a href="#basics">射线检测基础</a></li>
                        <li><a href="#methods">射线检测方法详解</a></li>
                        <li><a href="#special-shapes">特殊形状检测</a></li>
                        <li><a href="#applications">实际应用场景</a></li>
                        <li><a href="#advanced">高级射线检测技术</a></li>
                        <li><a href="#optimization">性能优化和最佳实践</a></li>
                        <li><a href="#troubleshooting">常见问题和解决方案</a></li>
                        <li><a href="#conclusion">总结</a></li>
                    </ul>
                </nav>
            </div>
        </aside>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Tech Blog</h3>
                    <p>分享技术，传播知识</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul class="footer-links">
                        <li><a href="../index.html#home">首页</a></li>
                        <li><a href="../index.html#works">作品</a></li>
                        <li><a href="../index.html#articles">文章</a></li>
                        <li><a href="../index.html#about">关于</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>技术栈</h4>
                    <ul class="footer-links">
                        <li><a href="#">Unity</a></li>
                        <li><a href="#">C#</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Tech Blog. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="../script.js"></script>
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-list a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight active section in TOC
        const sections = document.querySelectorAll('.article-section');
        const tocLinks = document.querySelectorAll('.toc-list a');

        const observerOptions = {
            root: null,
            rootMargin: '-20% 0px -70% 0px',
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    tocLinks.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, observerOptions);

        sections.forEach(section => {
            observer.observe(section);
        });
    </script>
</body>
</html>